Chapter 09. Hierarchical Models
================
A Solomon Kurz
2018-10-10

Hierarchical Models
===================

As Kruschke put it: "There are many realistic situations that involve meaningful hierarchical structure. Bayesian modeling software makes it straightforward to specify and analyze complex hierarchical models" (p. 221). IMO, brms makes it even easier than JAGS.

A single coin from a single mint
--------------------------------

Recall from the last chapter that our likelihood is the Bernoulli distribution:

*y*<sub>*i*</sub> ∼ *B**e**r**n**o**u**l**l**i*(*θ*)

We'll use the Beta density for our prior distribution for *θ*:

*θ* ∼ *B**e**t**a*(*α*, *β*)

And we can re-express *α* and *β* in terms of the mode *ω* and concentration *κ*, such that

*α* = *ω*(*κ* − 2)+1 and *β* = (1 − *ω*)(*κ* − 2)+1

The consequence of this is that we can re-express *θ* as

*θ* ∼ *B**e**t**a*(*ω*(*κ* − 2)+1, (1 − *ω*)(*κ* − 2)+1)

On page 224, Kruschke wrote: "The value of *κ* governs how near *θ* is to *ω*, with larger values of *κ* generating values of *θ* more concentrated near *ω*." To give a sense of that, we'll simulate 20 beta distributions, all with *ω* = .25 but with *θ* increasing from 10 to 200, by 10.

``` r
library(tidyverse)
library(ggridges)

beta_by_k <- function(k){
  w <- .25
  tibble(x = seq(from = 0, to = 1, length.out = 1000)) %>% 
    mutate(theta = dbeta(x = x,
                         shape1 = w * (k - 2) + 1,
                         shape2 = (1 - w) * (k - 2) + 1))
}

tibble(k = seq(from = 10, to = 200, by = 10)) %>% 
  mutate(theta = map(k, beta_by_k)) %>% 
  unnest() %>%
  
  ggplot(aes(x = x, y = k,
             height = theta,
             group = k, fill = k)) +
  geom_vline(xintercept = c(0, .25, .5), color = "grey85", size = 1/2) +
  geom_ridgeline(size = 1/4, color = "white", scale = 2) +
  scale_fill_viridis_c(expression(kappa), option = "A") +
  scale_y_continuous(breaks = seq(from = 10, to = 200, by = 10)) +
  labs(x = expression(theta),
       y = expression(kappa)) +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-1-1.png)

Holding *ω* constant, the density gets more concentrated around *ω* as *κ* increases.

### Posterior via grid approximation.

Given *α* and *β*, we can compute their mode *ω*. To foreshadow, consider Beta(2, 2).

``` r
alpha <- 2
beta  <- 2

(alpha - 1) / (alpha + beta - 2)
```

    ## [1] 0.5

That is, the mode of Beta(2, 2)=.5.

We won’t be able to make the wireframe plots on the left of Figure 9.2, but we can make the others. We'll make the initial data following Kruschke's (p. 226) formulas

*p*(*θ*, *ω*)=*p*(*θ*|*ω*)*p*(*ω*)=Beta(*θ*|*ω*(100 − 2)+1, (1 − *ω*)(100 − 2)+1)Beta(*ω*|2, 2)

First, we'll make a custom function, `make_prior()` based on the formulas.

``` r
make_prior <- function(theta, omega){
  dbeta(x = theta,
        shape1 =      omega  * (kappa - 2) + 1,
        shape2 = (1 - omega) * (kappa - 2) + 1) *
    dbeta(x = omega,
          shape1 = alpha,
          shape2 = beta)
  }
```

We already assigned values to `alpha` and `beta`, above. They're both 2. Next we'll define the parameter space as a sequence from 0 to 1 and assign the value of 100 to `kappa`.

``` r
parameter_space <- seq(from = 0, to = 1, by = .01)
kappa <- 100
```

Our `make_prior()` function had five variables. We've saved the values of three of them into working memory (i.e., `alpha`, `beta`, and `kappa`). Now we'll use `parameter_space` to define the ranges for the final two variables, `theta` and `omega`, which we'll save in a tibble. We'll then feed the `theta` and `omega` values into our function via `purrr::map2()`, which will return a nested tibble. Once we `unnest()` the tibble, we'll be ready to plot the top middle panel of Figure 9.2.

``` r
d <-
  tibble(theta = parameter_space,
         omega = parameter_space) %>%
  expand(theta, omega) %>% 
  mutate(prior = map2(theta, omega, make_prior)) %>% 
  unnest() %>% 
  # here we normalize (i.e., translate the prior from the density metric to the probability metric)
  mutate(prior = prior / sum(prior))

d %>% 
  ggplot(aes(x = theta, y = omega, fill = prior)) +
  geom_tile() +
  scale_fill_viridis_c(option = "A") +
  labs(x = expression(theta),
       y = expression(omega)) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-5-1.png)

If we collapse "the joint prior across *θ*" (i.e., `group_by(omega)` and then `sum(prior)`), we plot the marginal distribution for *p*(*ω*) as seen in the top right panel.

``` r
d %>%
  group_by(omega) %>% 
  summarise(prior = sum(prior)) %>% 
  
  ggplot(aes(x = omega,
             ymin = 0,
             ymax = prior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(omega),
       y = expression(paste("Marginal p(", omega, ")"))) +
  coord_flip(ylim = c(0, .03)) +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-6-1.png)

We'll follow a similar procedure to get the marginal probability distribution for `theta`.

``` r
d %>%
  group_by(theta) %>% 
  summarise(prior = sum(prior)) %>% 
  
  ggplot(aes(x = theta,
             ymin = 0,
             ymax = prior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(theta),
       y = expression(paste("Marginal p(", theta, ")"))) +
  coord_cartesian(ylim = c(0, .03)) +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-7-1.png)

With a little `filter()`ing and wrangling, we’ll be in good shape to make the two short plots in the right panel of the second row from the top.

``` r
d %>% 
  filter(omega %in% c(.25, .75)) %>% 
  mutate(label = str_c("omega == ", omega)) %>% 
  mutate(label = factor(label, levels = c("omega == 0.75", "omega == 0.25"))) %>% 
  
  ggplot(aes(x = theta,
             ymin = 0,
             ymax = prior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(theta),
       y = expression(paste("p(", theta, "|", omega, ")"))) +
  coord_cartesian() +
  theme(panel.grid = element_blank()) +
  facet_wrap(~label, ncol = 1, labeller = label_parsed)
```

![](09_files/figure-markdown_github/unnamed-chunk-8-1.png)

As Kruschke pointed out at the top of page 228, these are indeed Beta densities.

``` r
# we'll want this for the annotation
text <-
  tibble(theta = c(.75, .25),
         y = 10.5,
         label = c("Beta(74.5, 25.5)", "Beta(25.5, 74.5)"),
         omega = letters[1:2])

# here's the primary data for the plot
tibble(theta = rep(parameter_space, times = 2),
       alpha = rep(c(74.5, 25.5),   each = 101),
       beta  = rep(c(25.5, 74.5),   each = 101),
       omega = rep(letters[1:2],    each = 101)) %>%
  
  # the plot
  ggplot(aes(x     = theta,
             ymin  = 0,
             ymax  = dbeta(x = theta, shape1 = alpha, shape2 = beta), 
             fill  = omega)) +
  geom_ribbon() +
  geom_text(data = text,
            aes(y = y, label = label, color = omega)) +
  scale_fill_viridis_d(option = "A", begin = .3, end = .7) +
  scale_color_viridis_d(option = "A", begin = .3, end = .7) +
  labs(x = expression(theta),
       y = "density") +
  coord_cartesian(ylim = 0:12) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-9-1.png)

We need the Bernoulli likelihood function for the lower three rows of Figure 9.2.

``` r
Bernoulli_likelihood <- function(theta, data) {
  # theta = success probability parameter ranging from 0 to 1
  # data = the vector of data (i.e., a series of 0s and 1s)
  N <- length(data)
  z <- sum(data)
  return(theta^z * (1 - theta)^(N - sum(data)))
  }
```

Time to feed `theta` and our data into `Bernoulli_likelihood()`, which will allow us to make the 2-dimensional density plot in the middle of Figure 9.2.

``` r
N <- 12
z <- 9

trial_data <- rep(0:1, times = c(N - z, z))

d <-
  d %>% 
  mutate(likelihood = Bernoulli_likelihood(theta = theta, 
                                           data  = trial_data))

d %>%
  ggplot(aes(x = theta, y = omega, fill = likelihood)) +
  geom_tile() +
  scale_fill_viridis_c(option = "A") +
  labs(x = expression(theta),
       y = expression(omega)) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-11-1.png)

From formula 9.1, the posterior *p*(*θ*, *ω*|*D*) is proportional to *p*(*D*|*θ*)*p*(*θ*|*ω*)*p*(*ω*). Divide by the normalizing constant and we'll have it in a proper probability metric.

Our first depiction will be the middle panel of the second row from the bottom.

``` r
d <-
  d %>% 
  mutate(posterior = (likelihood * prior * omega) / sum(likelihood * prior * omega)) 

d %>% 
  ggplot(aes(x = theta, y = omega, fill = posterior)) +
  geom_tile() +
  scale_fill_viridis_c(option = "A") +
  labs(x = expression(theta),
       y = expression(omega)) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-12-1.png)

Making the marginal plots for `posterior` is much like when making them for `prior`, above.

``` r
# for omega
d %>%
  group_by(omega) %>% 
  summarise(posterior = sum(posterior)) %>% 
  
  ggplot(aes(x = omega,
             ymin = 0,
             ymax = posterior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(omega),
       y = expression(paste("Marginal p(", omega, "|D)"))) +
  coord_flip() +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-13-1.png)

``` r
# for theta
d %>%
  group_by(theta) %>% 
  summarise(posterior = sum(posterior)) %>% 
  
  ggplot(aes(x = theta,
             ymin = 0,
             ymax = posterior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(theta),
       y = expression(paste("Marginal p(", theta, "|D)"))) +
  coord_cartesian() +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-13-2.png)

And like above, we'll `filter()` and wrangle to make the short plots in the lower right panel of Figure 9.2.

``` r
d %>% 
  filter(omega %in% c(.25, .75)) %>% 
  mutate(label = str_c("omega == ", omega)) %>% 
  mutate(label = factor(label, levels = c("omega == 0.75", "omega == 0.25"))) %>% 
  
  ggplot(aes(x = theta,
             ymin = 0,
             ymax = posterior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(theta),
       y = expression(paste("p(", theta, "|", omega, ")"))) +
  # coord_cartesian(ylim = 0:10) +
  theme(panel.grid = element_blank()) +
  facet_wrap(~label, ncol = 1, labeller = label_parsed, scales = "free")
```

![](09_files/figure-markdown_github/unnamed-chunk-14-1.png)

Before we repeat the process for Figure 9.3, we'll redefine our constants.

``` r
alpha <- 20
beta  <- 20
kappa <- 6
```

Here's the initial data and the 2-dimensional density plot for the prior.

``` r
d <-
  tibble(theta = parameter_space,
         omega = parameter_space) %>%
  expand(theta, omega) %>% 
  mutate(prior = map2(theta, omega, make_prior)) %>% 
  unnest() %>% 
  mutate(prior = prior / sum(prior))

d %>% 
  ggplot(aes(x = theta, y = omega, fill = prior)) +
  geom_tile() +
  scale_fill_viridis_c(option = "A") +
  labs(x = expression(theta),
       y = expression(omega)) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-16-1.png)

Now we'll average over `omega` and `theta` to plot their marginal prior distributions.

``` r
# for omega
d %>%
  group_by(omega) %>% 
  summarise(prior = sum(prior)) %>% 
  
  ggplot(aes(x = omega,
             ymin = 0,
             ymax = prior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(omega),
       y = expression(paste("Marginal p(", omega, ")"))) +
  coord_flip() +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-17-1.png)

``` r
# for theta
d %>%
  group_by(theta) %>% 
  summarise(prior = sum(prior)) %>% 
  
  ggplot(aes(x = theta,
             ymin = 0,
             ymax = prior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(theta),
       y = expression(paste("Marginal p(", theta, ")"))) +
  coord_cartesian(ylim = c(0, .03)) +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-17-2.png)

Here are the two short plots in the right panel of the second row from the top of Figure 9.3.

``` r
d %>% 
  filter(omega %in% c(.25, .75)) %>% 
  mutate(label = str_c("omega == ", omega)) %>% 
  mutate(label = factor(label, levels = c("omega == 0.75", "omega == 0.25"))) %>% 
  
  ggplot(aes(x = theta,
             ymin = 0,
             ymax = prior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(theta),
       y = expression(paste("p(", theta, "|", omega, ")"))) +
  coord_cartesian(ylim = c(0, 6e-06)) +
  theme(panel.grid = element_blank()) +
  facet_wrap(~label, ncol = 1, labeller = label_parsed)
```

![](09_files/figure-markdown_github/unnamed-chunk-18-1.png)

Now we're ready for the likelihood.

``` r
d <-
  d %>% 
  mutate(likelihood = Bernoulli_likelihood(theta = theta, 
                                           data  = trial_data))

d %>%
  ggplot(aes(x = theta, y = omega, fill = likelihood)) +
  geom_tile() +
  scale_fill_viridis_c(option = "A") +
  labs(x = expression(theta),
       y = expression(omega)) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-19-1.png)

Here's the posterior, *p*(*θ*|D). Our first depiction will be the middle panel of the second row from the bottom of Figure 9.3.

``` r
d <-
  d %>% 
  # mutate(marginal_likelihood = sum(prior * likelihood)) %>% 
  mutate(posterior = (likelihood * prior * omega) / sum(likelihood * prior * omega)) 

d %>% 
  ggplot(aes(x = theta, y = omega, fill = posterior)) +
  geom_tile() +
  scale_fill_viridis_c(option = "A") +
  labs(x = expression(theta),
       y = expression(omega)) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-20-1.png)

Here are the marginal plots for `posterior`.

``` r
# for omega
d %>%
  group_by(omega) %>% 
  summarise(posterior = sum(posterior)) %>% 
  
  ggplot(aes(x = omega,
             ymin = 0,
             ymax = posterior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(omega),
       y = expression(paste("Marginal p(", omega, "|D)"))) +
  coord_flip() +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-21-1.png)

``` r
# for theta
d %>%
  group_by(theta) %>% 
  summarise(posterior = sum(posterior)) %>% 
  
  ggplot(aes(x = theta,
             ymin = 0,
             ymax = posterior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(theta),
       y = expression(paste("Marginal p(", theta, "|D)"))) +
  coord_cartesian() +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-21-2.png)

And we'll finish off with the plots of Figure 9.3's lower right panel.

``` r
d %>% 
  filter(omega %in% c(.25, .75)) %>% 
  mutate(label = str_c("omega == ", omega)) %>% 
  mutate(label = factor(label, levels = c("omega == 0.75", "omega == 0.25"))) %>% 
  
  ggplot(aes(x = theta,
             ymin = 0,
             ymax = posterior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(theta),
       y = expression(paste("p(", theta, "|", omega, ")"))) +
  theme(panel.grid = element_blank()) +
  facet_wrap(~label, ncol = 1, labeller = label_parsed, scales = "free")
```

![](09_files/figure-markdown_github/unnamed-chunk-22-1.png)

Multiple coins from a single mint
---------------------------------

Kruschke provided our motivation on page 230: "What if we collect data from more than one coin created by the mint? If each coin has its own distinct bias *θ*s, then we are estimating a distinct parameter value for each coin, and using all the data to estimate *ω*."

### Posterior via grid approximation.

Here's my attempt at the multiple coins prior.

``` r
alpha <- 2
beta  <- 2
kappa <- 5

d <-
  tibble(theta_1 = parameter_space,
         omega   = parameter_space) %>%
  expand(theta_1, omega) %>% 
  # the second column of theta values is a duplicate of the first
  mutate(theta_2 = theta_1) %>% 
  mutate(prior_1 = map2(theta_1, omega, make_prior),
         prior_2 = map2(theta_2, omega, make_prior)) %>% 
  unnest() %>% 
  # here we normalize
  mutate(prior_1 = prior_1 / sum(prior_1),
         prior_2 = prior_2 / sum(prior_2))

head(d)  
```

    ## # A tibble: 6 x 5
    ##   theta_1 omega theta_2 prior_1 prior_2
    ##     <dbl> <dbl>   <dbl>   <dbl>   <dbl>
    ## 1       0  0          0       0       0
    ## 2       0  0.01       0       0       0
    ## 3       0  0.02       0       0       0
    ## 4       0  0.03       0       0       0
    ## 5       0  0.04       0       0       0
    ## 6       0  0.05       0       0       0

The left and middle columns of the top two rows are the same save for their indices. So I'm just going to focus on those from `theta_1`. Here's the 2-dimensional density of the upper left panel.

``` r
d %>% 
  ggplot(aes(x = theta_1, y = omega, fill = prior_1)) +
  geom_tile() +
  scale_fill_viridis_c(option = "A") +
  labs(x = expression(theta[1]),
       y = expression(omega)) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-24-1.png)

Now we'll average over `omega` and `theta` to plot their marginal prior distributions.

``` r
# for omega
d %>%
  group_by(omega) %>% 
  summarise(prior = sum(prior_1 + prior_2)) %>% 
  
  ggplot(aes(x = omega,
             ymin = 0,
             ymax = prior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(omega),
       y = expression(paste("p(", omega, ")"))) +
  coord_flip(ylim = c(0, .08)) +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-25-1.png)

``` r
# for theta
d %>%
  group_by(theta_1) %>% 
  summarise(prior = sum(prior_1 + prior_2)) %>% 

  ggplot(aes(x = theta_1,
             ymin = 0,
             ymax = prior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(theta[1]),
       y = expression(paste("p(", theta[1], ")"))) +
  coord_cartesian(ylim = c(0, .08)) +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-25-2.png)

Now we'll add the likelihoods and make the plots in the middle row of Figure 9.5.

``` r
# D1: 3 heads, 12 tails
N <- 15
z <- 3

trial_data_1 <- rep(0:1, times = c(N - z, z))

# D2: 4 heads, 1 tail
N <- 5
z <- 4

trial_data_2 <- rep(0:1, times = c(N - z, z))
d <-
  d %>% 
  mutate(likelihood_1 = Bernoulli_likelihood(theta = theta_1, 
                                             data  = trial_data_1),
         likelihood_2 = Bernoulli_likelihood(theta = theta_2, 
                                             data  = trial_data_2))

# likelihood_1
d %>%
  ggplot(aes(x = theta_1, y = omega, fill = likelihood_1)) +
  geom_tile() +
  scale_fill_viridis_c(option = "A") +
  labs(x = expression(theta[1]),
       y = expression(omega)) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-26-1.png)

``` r
# likelihood_2
d %>%
  ggplot(aes(x = theta_2, y = omega, fill = likelihood_2)) +
  geom_tile() +
  scale_fill_viridis_c(option = "A") +
  labs(x = expression(theta[2]),
       y = expression(omega)) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-26-2.png)

The likelihoods look good. Next I attempted to make the posteriors. Carefully compare the following plots with their analogues in Figure 9.5 and you'll see I've erred somewhere. If you maths are better than mine and you spot where I've gone wrong, [please share your code](https://github.com/ASKurz/Doing-Bayesian-Data-Analysis-in-brms-and-the-tidyverse/issues).

``` r
d <-
  d %>% 
  mutate(posterior_1 = (omega * prior_1 * likelihood_1) / sum(omega * prior_1 * likelihood_1),
         posterior_2 = (omega * prior_2 * likelihood_2) / sum(omega * prior_2 * likelihood_2))

# posterior_1
d %>% 
  ggplot(aes(x = theta_1, y = omega, fill = posterior_1 * omega)) +
  geom_tile() +
  scale_fill_viridis_c(option = "A") +
  labs(x = expression(theta[1]),
       y = expression(omega)) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-27-1.png)

``` r
# posterior_2
d %>% 
  ggplot(aes(x = theta_2, y = omega, fill = posterior_2)) +
  geom_tile() +
  scale_fill_viridis_c(option = "A") +
  labs(x = expression(theta[2]),
       y = expression(omega)) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-27-2.png)

See? The posterior for *θ*<sub>2</sub> is concentrated to highly on the *ω*-axis. You'll note that the next plot, the marginal for *ω*, is a little too contentrated toward the top, too.

``` r
d %>%
  group_by(omega) %>% 
  summarise(posterior = sum(posterior_2 + posterior_1)) %>% 
  
  ggplot(aes(x = omega,
             ymin = 0,
             ymax = posterior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(omega),
       y = expression(paste("p(", omega, "|D)"))) +
  coord_flip() +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-28-1.png)

Here are the marginal plots on the bottom row of Figure 9.5.

``` r
# for theta_1
d %>%
  group_by(theta_1) %>% 
  summarise(posterior = sum(posterior_1)) %>% 
  
  ggplot(aes(x = theta_1,
             ymin = 0,
             ymax = posterior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(theta[1]),
       y = expression(paste("p(", theta[1], "|D)"))) +
  coord_cartesian(ylim = c(0, .04)) +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-29-1.png)

``` r
# for theta_2
d %>%
  group_by(theta_2) %>% 
  summarise(posterior = sum(posterior_2)) %>% 
  
  ggplot(aes(x = theta_2,
             ymin = 0,
             ymax = posterior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(theta[2]),
       y = expression(paste("p(", theta[2], "|D)"))) +
  coord_cartesian(ylim = c(0, .04)) +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-29-2.png)

We'll do this dog and pony one more time for Figure 9.6, which uses different priors on the same data.

``` r
alpha <- 2
beta  <- 2
kappa <- 75

d <-
  tibble(theta_1 = parameter_space,
         omega   = parameter_space) %>%
  expand(theta_1, omega) %>% 
  # the second column of theta values is a duplicate of the first
  mutate(theta_2 = theta_1) %>% 
  mutate(prior_1 = map2(theta_1, omega, make_prior),
         prior_2 = map2(theta_2, omega, make_prior)) %>% 
  unnest() %>% 
  # here we normalize
  mutate(prior_1 = prior_1 / sum(prior_1),
         prior_2 = prior_2 / sum(prior_2))

# 2-D prior density for theta_1
d %>% 
  ggplot(aes(x = theta_1, y = omega, fill = prior_1)) +
  geom_tile() +
  scale_fill_viridis_c(option = "A") +
  labs(x = expression(theta[1]),
       y = expression(omega)) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-30-1.png)

``` r
# marginal for omega
d %>%
  group_by(omega) %>% 
  summarise(prior = sum(prior_1 + prior_2)) %>% 
  
  ggplot(aes(x = omega,
             ymin = 0,
             ymax = prior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(omega),
       y = expression(paste("p(", omega, ")"))) +
  coord_flip(ylim = c(0, .08)) +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-30-2.png)

``` r
# marginal for theta_1
d %>%
  group_by(theta_1) %>% 
  summarise(prior = sum(prior_1 + prior_2)) %>% 
  
  ggplot(aes(x = theta_1,
             ymin = 0,
             ymax = prior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(theta[1]),
       y = expression(paste("p(", theta[1], ")"))) +
  coord_cartesian(ylim = c(0, .08)) +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-30-3.png)

Likelihoods:

``` r
d <-
  d %>% 
  mutate(likelihood_1 = Bernoulli_likelihood(theta = theta_1, 
                                             data  = trial_data_1),
         likelihood_2 = Bernoulli_likelihood(theta = theta_2, 
                                             data  = trial_data_2))

# likelihood_1
d %>%
  ggplot(aes(x = theta_1, y = omega, fill = likelihood_1)) +
  geom_tile() +
  scale_fill_viridis_c(option = "A") +
  labs(x = expression(theta[1]),
       y = expression(omega)) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-31-1.png)

``` r
# likelihood_2
d %>%
  ggplot(aes(x = theta_2, y = omega, fill = likelihood_2)) +
  geom_tile() +
  scale_fill_viridis_c(option = "A") +
  labs(x = expression(theta[2]),
       y = expression(omega)) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-31-2.png)

The posteriors already look suspicious.

``` r
d <-
  d %>% 
  mutate(posterior_1 = (likelihood_1 * prior_1 * omega) / sum(likelihood_1 * prior_1 * omega),
         posterior_2 = (likelihood_2 * prior_2 * omega) / sum(likelihood_2 * prior_2 * omega))

# posterior_1
d %>% 
  ggplot(aes(x = theta_1, y = omega, fill = posterior_1)) +
  geom_tile() +
  scale_fill_viridis_c(option = "A") +
  labs(x = expression(theta[1]),
       y = expression(omega)) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-32-1.png)

``` r
# posterior_2
d %>% 
  ggplot(aes(x = theta_2, y = omega, fill = posterior_2)) +
  geom_tile() +
  scale_fill_viridis_c(option = "A") +
  labs(x = expression(theta[2]),
       y = expression(omega)) +
  theme(panel.grid = element_blank(),
        legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-32-2.png)

My attempt at the marginal for *ω*.

``` r
d %>%
  group_by(omega) %>% 
  summarise(posterior = sum(posterior_2 + posterior_1)) %>% 
  
  ggplot(aes(x = omega,
             ymin = 0,
             ymax = posterior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(omega),
       y = expression(paste("p(", omega, "|D)"))) +
  coord_flip(ylim = c(0, .04)) +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-33-1.png)

Yep, now it's clear something definately went wrong. Finally, here are the marginal plots on the bottom row of Figure 9.5.

``` r
# for theta_1
d %>%
  group_by(theta_1) %>% 
  summarise(posterior = sum(posterior_1)) %>% 
  
  ggplot(aes(x = theta_1,
             ymin = 0,
             ymax = posterior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(theta),
       y = expression(paste("p(", theta[1], "|D)"))) +
  coord_cartesian(ylim = c(0, .04)) +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-34-1.png)

``` r
# for theta_2
d %>%
  group_by(theta_2) %>% 
  summarise(posterior = sum(posterior_2)) %>% 
  
  ggplot(aes(x = theta_2,
             ymin = 0,
             ymax = posterior)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(theta),
       y = expression(paste("p(", theta[2], "|D)"))) +
  coord_cartesian(ylim = c(0, .04)) +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-34-2.png)

Again, I've clearly erred somewhere. If you spot where I've gone wrong, [please share your code](https://github.com/ASKurz/Doing-Bayesian-Data-Analysis-in-brms-and-the-tidyverse/issues).

### A realistic model with MCMC.

Here' a look at the gamma densities of Figure 9.8.

``` r
length <- 100

tibble(x = seq(from = 0, to = 200, length.out = length) %>% 
         rep(., times = 4)) %>% 
  mutate(shape = rep(c(.01, 1.56, 1, 6.25), each = length),
         rate = rep(c(.01, .0312, .02, .125), each = length)) %>% 
  mutate(mean = shape * 1/rate,
         sd = sqrt(shape * (1 / rate)^2)) %>% 
  mutate(label = str_c("shape = ", shape, ", rate = ", rate, 
                       "\nmean = ", mean, ", sd = ", sd)) %>% 
  
  ggplot(aes(x = x, 
             ymin = 0, 
             ymax = dgamma(x = x, shape = shape, rate = rate))) +
  geom_ribbon(fill = "grey67") +
  scale_y_continuous(breaks = c(0, .01, .02)) +
  coord_cartesian(xlim = 0:150) +
  labs(x = expression(kappa),
       y = expression(paste("p(", kappa, "|s, r)"))) +
  theme(panel.grid = element_blank()) +
  facet_wrap(~label)
```

![](09_files/figure-markdown_github/unnamed-chunk-35-1.png)

You can find the formulas for the mean and *S**D* for a given gamma distribution [here](http://astrostatistics.psu.edu/su07/R/html/stats/html/GammaDist.html). We use those formulas in the second `mutate()` statement for the data-prep stage of our Figure 9.8.

Kruschke's equations 9.7 and 9.8 are as follows:

$$s = \\frac{\\mu^2}{\\sigma^2} \\text{ and } r = \\frac{\\mu}{\\sigma^2} \\text{ for mean } \\mu &gt; 0$$

$$s = 1 + \\omega r \\text{ where } r = \\frac{\\omega + \\sqrt{\\omega^2 + 4\\sigma^2}}{2\\sigma^2} \\text{ for mode } \\omega &gt; 0$$

With those in hand, we can follow Kruschke's "DBDA2E-utilities.R" file to make a couple convenience functions.

``` r
gamma_s_and_r_from_mean_sd <- function(mean, sd) {
  if (mean <= 0) stop("mean must be > 0")
  if (sd   <= 0) stop("sd must be > 0")
  shape <- mean^2 / sd^2
  rate  <- mean   / sd^2
  return(list(shape = shape, rate = rate))
}

gamma_s_and_r_from_mode_sd <- function(mode, sd) {
  if (mode <= 0) stop("mode must be > 0")
  if (sd   <= 0) stop("sd must be > 0")
  rate  <- (mode + sqrt(mode^2 + 4 * sd^2)) / (2 * sd^2)
  shape <- 1 + mode * rate
  return(list(shape = shape, rate = rate))
}
```

They're easy to put to use:

``` r
gamma_s_and_r_from_mean_sd(mean = 10, sd = 100)
```

    ## $shape
    ## [1] 0.01
    ## 
    ## $rate
    ## [1] 0.001

``` r
gamma_s_and_r_from_mode_sd(mode = 10, sd = 100)
```

    ## $shape
    ## [1] 1.105125
    ## 
    ## $rate
    ## [1] 0.01051249

``` r
gamma_param <- gamma_s_and_r_from_mode_sd(mode = 10, sd = 100)

str(gamma_param)
```

    ## List of 2
    ##  $ shape: num 1.11
    ##  $ rate : num 0.0105

### Doing it with ~~JAGS~~ brms.

Unlike JAGS, the brms `formula` will not correspond as closely to Figure 9.7. You'll see in just a bit.

### Example: Therapeutic touch.

``` r
my_data <- read_csv("data.R/TherapeuticTouchData.csv")

glimpse(my_data)
```

    ## Observations: 280
    ## Variables: 2
    ## $ y <int> 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, ...
    ## $ s <chr> "S01", "S01", "S01", "S01", "S01", "S01", "S01", "S01", "S01...

Here are what the data look like:

``` r
my_data %>% 
  mutate(y = y %>% as.character()) %>% 
  
  ggplot(aes(x = y)) +
  geom_bar(aes(fill = stat(count))) +
  scale_y_continuous(breaks = seq(from = 0, to = 9, by = 3)) +
  scale_fill_viridis_c(option = "A", end = .7) +
  coord_flip() +
  theme(legend.position = "none",
        panel.grid = element_blank()) +
  facet_wrap(~s, ncol = 7)
```

![](09_files/figure-markdown_github/unnamed-chunk-40-1.png)

And here's our Figure 9.9.

``` r
my_data %>% 
  group_by(s) %>% 
  summarize(mean = mean(y)) %>%
  
  ggplot(aes(x = mean)) +
  geom_histogram(color = "grey92", fill = "grey67",
                 size = .2, binwidth = .1) +
  coord_cartesian(xlim = 0:1) +
  labs(x = "Proportion Correct",
       y = "# Practitioners") +
  theme(panel.grid = element_blank())
```

![](09_files/figure-markdown_github/unnamed-chunk-41-1.png)

Let's open brms.

``` r
library(brms)
```

In applied statistics, the typical way to model a Bernoulli variable is with logistic regression. Instead of going through the pain of setting up a model in brms that mirror’s the one in the text, I’m going to set up a hierarchical logistic regression model, instead.

Note the `family = bernoulli(link = "logit")` argument. In work-a-day regression with vanilla Gaussian variables, the prediction space is unbounded. But when we want to model the probability of a success for a Bernoulli variable (i.e., *θ*), we need to constrain the model to only produce predictions between 0 and 1. With logistic regression, we use a link function to do just that. The consequence is that instead of modeling the probability, *θ*, we’re modeling the logit probability.

In case you're curious, the logit of *θ* is:

*l**o**g**i**t*(*θ*)=*l**o**g*(*θ*/(1 − *θ*))

But anyway, we'll be doing logistic regression using the logit link. Kruschke will cover this in detail in chapter 21.

The next new part of our syntax is `(1 | s)`. As in the popular frequentist [lme4 package](https://cran.r-project.org/web/packages/lme4/index.html), you specify random effects or group-level parameters with the `(|)` syntax in brms. On the left side of the `|`, you tell brms what parameters you'd like to make random (i.e., vary by group). On the right side of the `|`, you tell brms what variable you want to group the parameters by. In our case, we want the intercepts to be grouped by `s`.

``` r
fit1 <-
  brm(data = my_data,
      family = bernoulli(link = "logit"),
      y ~ 1 + (1 | s),
      prior = c(prior(normal(0, 1.5), class = Intercept),
                prior(normal(0, 1), class = sd)),
      iter = 20000, warmup = 1000, thin = 10, chains = 4, cores = 4)
```

As it turns out, the *N*(0, 1.5) prior is flat in the probability space for the intercept in a logistic regression model. We’ll explore that a little further down. The *N*(0, 1) prior for the random effect is actually a half-Normal. That’s because brms defaults to bound *S**D* parameters to zero and above. The half *N*(0, 1) prior for a hierarchical *S**D* parameter is weakly regularizing and is conservative in the sense that it presumes some pooling is preferable to no pooling. If you wanted to take a lighter approach, you might use something like a `cauchy(0, 5)`, instead. See the [prior wiki](https://github.com/stan-dev/stan/wiki/Prior-Choice-Recommendations) by the Stan team for more.

Here are the trace plots and posterior densities of the main parameters.

``` r
plot(fit1)
```

![](09_files/figure-markdown_github/unnamed-chunk-43-1.png)

The trace plots indicate no problems with convergence. We'll need to extract the posterior samples and open the bayesplot package before we can examine the autocorrelations.

``` r
post <- posterior_samples(fit1, add_chain = T)

library(bayesplot)
```

One of the nice things about bayesplot is it returns ggplot2 objects. As such, we can amend their theme settings to be consistent with our other ggplot2 plots. The `theme_set()` function will make that particularly easy. And since I prefer to plot without gridlines, we'll slip in a line on `panel.grid` to suppress them by default for the remainder of this chapter.

``` r
theme_set(theme_grey() +
            theme(panel.grid = element_blank()))
```

Now we're ready for `bayesplot::mcmc_acf()`.

``` r
mcmc_acf(post, pars = c("b_Intercept", "sd_s__Intercept"), lags = 10)
```

![](09_files/figure-markdown_github/unnamed-chunk-46-1.png)

It appears `fit1` had very low autocorrelations. Here we'll examine the *N*<sub>*e**f**f*</sub>/*N* ratio.

``` r
neff_ratio(fit1) %>% 
  mcmc_neff()
```

![](09_files/figure-markdown_github/unnamed-chunk-47-1.png)

The *N*<sub>*e**f**f*</sub>/*N* ratio values for our model parameters were excellent. And if you really wanted them, you could get the parameter labels on the y-axis by tacking `+ yaxis_text()` on at the end of the plot block.

Here's a numeric summary of the model:

``` r
print(fit1)
```

    ##  Family: bernoulli 
    ##   Links: mu = logit 
    ## Formula: y ~ 1 + (1 | s) 
    ##    Data: my_data (Number of observations: 280) 
    ## Samples: 4 chains, each with iter = 20000; warmup = 1000; thin = 10;
    ##          total post-warmup samples = 7600
    ## 
    ## Group-Level Effects: 
    ## ~s (Number of levels: 28) 
    ##               Estimate Est.Error l-95% CI u-95% CI Eff.Sample Rhat
    ## sd(Intercept)     0.28      0.18     0.01     0.69       7600 1.00
    ## 
    ## Population-Level Effects: 
    ##           Estimate Est.Error l-95% CI u-95% CI Eff.Sample Rhat
    ## Intercept    -0.25      0.14    -0.52     0.02       6693 1.00
    ## 
    ## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
    ## is a crude measure of effective sample size, and Rhat is the potential 
    ## scale reduction factor on split chains (at convergence, Rhat = 1).

We'll need `brms::inv_logit_scaled()` to convert the model parameters to predict *θ* rather than *l**o**g**i**t*(*θ*). After the conversions, we'll be ready to make the histograms in the lower portion of Figure 9.10.

``` r
library(tidybayes)

post_small <-
  post %>% 
  # converting the linter model to the probability space with `inv_logit_scaled()`
  mutate(`theta[1]`  = (b_Intercept + `r_s[S01,Intercept]`) %>% inv_logit_scaled(),
         `theta[14]` = (b_Intercept + `r_s[S14,Intercept]`) %>% inv_logit_scaled(),
         `theta[28]` = (b_Intercept + `r_s[S28,Intercept]`) %>% inv_logit_scaled()) %>% 
  # making the difference distributions
  mutate(`theta[1] - theta[14]`  = `theta[1]`  - `theta[14]`,
         `theta[1] - theta[28]`  = `theta[1]`  - `theta[28]`,
         `theta[14] - theta[28]` = `theta[14]` - `theta[28]`) %>% 
  select(starts_with("theta"))

post_small %>% 
  gather() %>% 
  # this line is unnecessary, but will help order the plots 
  mutate(key = factor(key, levels = c("theta[1]", "theta[14]", "theta[28]", 
                                      "theta[1] - theta[14]", "theta[1] - theta[28]", "theta[14] - theta[28]"))) %>% 

  ggplot(aes(x = value)) +
  geom_histogram(color = "grey92", fill = "grey67",
                 size = .2, bins = 30) +
  stat_pointintervalh(aes(y = 0), 
                      point_interval = mode_hdi, .width = .95) +
  scale_y_continuous(NULL, breaks = NULL) +
  xlab(NULL) +
  facet_wrap(~key, scales = "free", ncol = 3)
```

![](09_files/figure-markdown_github/unnamed-chunk-49-1.png)

If you wanted the specific values of the posterior modes and 95% HDIs, you could do:

``` r
post_small %>% 
  gather() %>%
  group_by(key) %>% 
  mode_hdi(value) %>% 
  mutate_if(is.double, round, digits = 3)
```

    ## # A tibble: 6 x 7
    ##   key                    value .lower .upper .width .point .interval
    ##   <chr>                  <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    
    ## 1 theta[1]               0.423  0.209  0.52    0.95 mode   hdi      
    ## 2 theta[1] - theta[14]  -0.003 -0.276  0.111   0.95 mode   hdi      
    ## 3 theta[1] - theta[28]  -0.009 -0.417  0.064   0.95 mode   hdi      
    ## 4 theta[14]              0.431  0.283  0.583   0.95 mode   hdi      
    ## 5 theta[14] - theta[28] -0.005 -0.309  0.122   0.95 mode   hdi      
    ## 6 theta[28]              0.452  0.357  0.696   0.95 mode   hdi

And here are the Figure 9.10 scatter plots.

``` r
library(gridExtra)

p1 <-
  post_small %>% 
  ggplot(aes(x = `theta[1]`, y = `theta[14]`)) +
  geom_abline(linetype = 1, color = "white") +
  geom_point(color = "grey50", size = 1/8, alpha = 1/8) +
  coord_cartesian(xlim = 0:1,
                  ylim = 0:1)

p2 <-
  post_small %>% 
  ggplot(aes(x = `theta[1]`, y = `theta[28]`)) +
  geom_abline(linetype = 1, color = "white") +
  geom_point(color = "grey50", size = 1/8, alpha = 1/8) +
  coord_cartesian(xlim = 0:1,
                  ylim = 0:1)

p3 <-
  post_small %>% 
  ggplot(aes(x = `theta[14]`, y = `theta[28]`)) +
  geom_abline(linetype = 1, color = "white") +
  geom_point(color = "grey50", size = 1/8, alpha = 1/8) +
  coord_cartesian(xlim = 0:1,
                  ylim = 0:1)

grid.arrange(p1, p2, p3, ncol = 3)
```

![](09_files/figure-markdown_github/unnamed-chunk-51-1.png)

This is posterior distribution for the population estimate for *θ*, which roughly corresponds to the upper right histogram of *ω* in Figure 9.10.

``` r
# this part makes it easier to set the break points in `scale_x_continuous()` 
labels <-
  post %>% 
  transmute(theta = b_Intercept %>% inv_logit_scaled()) %>%
  mode_hdi() %>% 
  select(theta:.upper) %>% 
  gather() %>% 
  mutate(label = value %>% round(3) %>% as.character) %>% 
  slice(1:3)
  
post %>% 
  mutate(theta = b_Intercept %>% inv_logit_scaled()) %>% 

  ggplot(aes(x = theta)) +
  geom_histogram(color = "grey92", fill = "grey67",
                 size = .2, bins = 30) +
  stat_pointintervalh(aes(y = 0), 
                      point_interval = mode_hdi, .width = .95) +
  scale_x_continuous(breaks = labels$value,
                     labels = labels$label) +  
  scale_y_continuous(NULL, breaks = NULL) +
  xlab(expression(theta))
```

![](09_files/figure-markdown_github/unnamed-chunk-52-1.png)

I'm not aware there's a straight conversion to get *σ* in a probability metric. As far as I can tell, you have to first use `coef()` to "extract \[the\] model coefficients, which are the sum of population-level effects and corresponding group-level effects" (p. 39 of the [user's guide for brms](https://cran.r-project.org/web/packages/brms/brms.pdf) version 2.5.0). With the model coefficient draws in hand, you can index them by posterior iteration, group them by that index, compute the iteration-level *S**D*s, and then plot the distribution of the *S**D*s.

``` r
# the tibble of the primary data
sigmas <-
  coef(fit1, summary = F)$s %>% 
  as_tibble() %>% 
  mutate(iter = 1:n()) %>% 
  group_by(iter) %>% 
  gather(key, value, -iter) %>% 
  mutate(theta = inv_logit_scaled(value)) %>% 
  summarise(sd = sd(theta))

# this, again, is just to customize `scale_x_continuous()`
labels <-
  sigmas %>% 
  mode_hdi(sd) %>% 
  select(sd:.upper) %>% 
  gather() %>% 
  mutate(label = value %>% round(3) %>% as.character) %>% 
  slice(1:3)
  
# the plot
sigmas %>% 
  ggplot(aes(x = sd)) +
  geom_histogram(color = "grey92", fill = "grey67",
                 size = .2, bins = 30, boundary = 0) +
  stat_pointintervalh(aes(y = 0), 
                      point_interval = mode_hdi, .width = .95) +
  scale_x_continuous(breaks = labels$value,
                     labels = labels$label) +  
  scale_y_continuous(NULL, breaks = NULL) +
  xlab(expression(paste(sigma, " of ", theta, " in a probability metric")))
```

![](09_files/figure-markdown_github/unnamed-chunk-53-1.png)

And now you have a sense of how to do all those by hand, `bayesplot::mcmc_pairs()` offers a farily quick way to get a good portion of Figure 9.10.

``` r
color_scheme_set("gray")
 
coef(fit1, summary = F)$s %>% 
  inv_logit_scaled() %>% 
  as_tibble() %>% 
  rename(`theta[1]` = S01.Intercept, 
         `theta[14]` = S14.Intercept, 
         `theta[28]` = S28.Intercept) %>% 
  select(`theta[1]`, `theta[14]`, `theta[28]`) %>% 
  
  mcmc_pairs(off_diag_args = list(size = 1/8, alpha = 1/8))
```

![](09_files/figure-markdown_github/unnamed-chunk-54-1.png)

Did you see how we slipped in that `color_scheme_set("gray")` line? When we used `theme_set()`, earlier, that changed the global theme settings for our ggplot2 plots. The `color_scheme_set()` function is specific to bayesplot plots and it sets the color palette within them. Setting the color palette "gray" changed the colors depicted in the dots and bars of the `mcmc_pairs()`-based scatter plots and histograms, respectively.

Kruschke used a beta(1, 1) prior for *ω*. If you randomly draw from that prior and plot a histogram, you’ll see it was flat.

``` r
set.seed(1)
tibble(prior = rbeta(n = 1e5, 1, 1)) %>% 
  ggplot(aes(x = prior)) +
  geom_histogram(color = "grey92", fill = "grey67", size = .2,
                 binwidth = .05, boundary = 0) +
  scale_x_continuous(labels = c("0", ".25", ".5", ".75", "1")) +
  scale_y_continuous(NULL, breaks = NULL) +
  coord_cartesian(xlim = 0:1) +
  xlab(expression(omega)) +
  theme(legend.position = "none")
```

![](09_files/figure-markdown_github/unnamed-chunk-55-1.png)

You'll note that plot corresponds to the upper right panel of Figure 9.11.

Recall that we used a logistic regression model with a `normal(0, 1.5)` prior on the intercept. If you sample from `normal(0, 1.5)` and then convert the draws using `brms::inv_logit_scaled()`, you'll discover that our `normal(0, 1.5)` prior was virtually flat on the probability scale. Here we'll show the consequence of a variety of zero-mean Gaussian priors for the intercept of a logistic regression model:

``` r
r_norm <- function(i, n = 1e4){
  set.seed(1)
  rnorm(n = n, mean = 0, sd = i) %>% 
    inv_logit_scaled()
}

tibble(sd = seq(from = .25, to = 3, by = .25)) %>% 
  group_by(sd) %>% 
  mutate(prior = map(sd, r_norm)) %>% 
  unnest() %>% 
  ungroup() %>% 
  mutate(sd = str_c("sd = ", sd)) %>% 
  
  ggplot(aes(x = prior)) +
  geom_histogram(fill = "grey67", color = "grey92", size = .2,
                 binwidth = .05, boundary = 0) +
  scale_x_continuous(labels = c("0", ".25", ".5", ".75", "1")) +
  scale_y_continuous(NULL, breaks = NULL) +
  coord_cartesian(xlim = 0:1) +
  facet_wrap(~sd)
```

![](09_files/figure-markdown_github/prior_sim-1.png)

It appears that as *σ* goes lower than 1.25, the prior becomes increasingly regularizing, pulling the estimate for *θ* to a neutral .5. However, as the prior’s *σ* gets larger than 1.25, more and more of the probability mass ends up at extreme values.

Here's the diagonal of the lower grid of Figure 9.11.

``` r
n <- 1e4

set.seed(1)
intercept_prior <- rnorm(n = n, mean = 0, sd = 1.5)
sigma_prior     <- rnorm(n = n, mean = 0, sd = 1) %>% abs()
 
prior_samples <-
  tibble(`theta[1]`  = rnorm(n = n, mean = intercept_prior, sd = sigma_prior) %>% inv_logit_scaled(),
         `theta[14]` = rnorm(n = n, mean = intercept_prior, sd = sigma_prior) %>% inv_logit_scaled(),
         `theta[28]` = rnorm(n = n, mean = intercept_prior, sd = sigma_prior) %>% inv_logit_scaled())

prior_samples %>% 
  gather() %>% 

  ggplot(aes(x = value)) +
  geom_histogram(fill = "grey67", color = "grey92", size = .2,
                binwidth = .05, boundary = 0) +
  scale_x_continuous(labels = c("0", ".25", ".5", ".75", "1")) +
  scale_y_continuous(NULL, breaks = NULL) +
  coord_cartesian(xlim = 0:1) +
  facet_wrap(~key)
```

![](09_files/figure-markdown_github/unnamed-chunk-56-1.png)

With a little subtraction, we can reproduce the plots in the upper triangle.

``` r
prior_samples %>% 
  mutate(`theta[1] - theta[14]`  = `theta[1]`  - `theta[14]`,
         `theta[1] - theta[28]`  = `theta[1]`  - `theta[28]`,
         `theta[14] - theta[28]` = `theta[14]` - `theta[28]`) %>% 
  select(contains("] - t")) %>% 
  gather() %>% 

  ggplot(aes(x = value)) +
  geom_histogram(fill = "grey67", color = "grey92", size = .2,
                binwidth = .05, boundary = 0) +
  scale_y_continuous(NULL, breaks = NULL) +
  facet_wrap(~key)
```

![](09_files/figure-markdown_github/unnamed-chunk-57-1.png)

Those plots clarify our hierarchical logistic regression model was a little more regularizing than Kruschke's. The consequence of our priors was more aggressive regularization, greater shrinkage toward zero. The prose in the next section of the text clarifies this isn’t necessarily a bad thing.

Finally, here are the plots for the lower triangle in Figure 9.11.

``` r
p1 <-
  prior_samples %>% 
  ggplot(aes(x = `theta[1]`, y = `theta[14]`)) +
  geom_point(color = "grey50", size = 1/8, alpha = 1/8) +
  geom_abline(linetype = 1, color = "white") +
  coord_cartesian(xlim = 0:1,
                  ylim = 0:1)

p2 <-
  prior_samples %>% 
  ggplot(aes(x = `theta[1]`, y = `theta[28]`)) +
  geom_point(color = "grey50", size = 1/8, alpha = 1/8) +
  geom_abline(linetype = 1, color = "white") +
  coord_cartesian(xlim = 0:1,
                  ylim = 0:1)

p3 <-
  prior_samples %>% 
  ggplot(aes(x = `theta[14]`, y = `theta[28]`)) +
  geom_point(color = "grey50", size = 1/8, alpha = 1/8) +
  geom_abline(linetype = 1, color = "white") +
  coord_cartesian(xlim = 0:1,
                  ylim = 0:1)

grid.arrange(p1, p2, p3, ncol = 3)
```

![](09_files/figure-markdown_github/unnamed-chunk-58-1.png)

Shrinkage in hierarchical models
--------------------------------

Recall formula 9.4 from page 223.

*θ* ∼ dbeta(*ω*(*κ* − 2)+1),(1 − *ω*)(*κ* − 2)+1)

With that formula, we can express `dbeta()`'s `shape1` and `shape2` in terms of *ω* and *κ* and make the shapes in Figure 9.12.

``` r
omega  <- 0.5
kappa1 <- 2.1
kappa2 <- 15.8

tibble(x = seq(from = 0, to = 1, by = .001)) %>%
  mutate(`kappa = 2.1` = dbeta(x = x, 
                               shape1 = omega * (kappa1 - 2) + 1, 
                               shape2 = (1 - omega) * (kappa1 - 2) + 1),
         `kappa = 15.8` = dbeta(x = x, 
                                shape1 = omega * (kappa2 - 2) + 1, 
                                shape2 = (1 - omega) * (kappa2 - 2) + 1)) %>% 
  gather(key, value, - x) %>% 
  mutate(key = factor(key, levels = c("kappa = 2.1", "kappa = 15.8"))) %>% 
  
  ggplot(aes(x = x, 
             ymin = 0,
             ymax = value)) +
  geom_ribbon(fill = "grey67") +
  labs(x = expression(paste("Data Proportion or ", theta, " value")),
       y = expression(paste("dbeta(", theta, "|", omega, ",", kappa, ")"))) +
  facet_wrap(~key)
```

![](09_files/figure-markdown_github/unnamed-chunk-59-1.png)

Speeding up ~~JAGS~~ brms
-------------------------

Here we'll compare the time it takes to fit `fit1` as either `bernoulli(link = "logit")` or `binomial(link = "logit")`.

``` r
# bernoulli
start_time_bernoulli <- proc.time()
brm(data = my_data,
      family = bernoulli(link = "logit"),
      y ~ 1 + (1 | s),
      prior = c(prior(normal(0, 1.5), class = Intercept),
                prior(normal(0, 1), class = sd)),
      iter = 20000, warmup = 1000, thin = 10, chains = 4, cores = 4)
stop_time_bernoulli <- proc.time()

# binomial
start_time_binomial <- proc.time()
brm(data = my_data,
      family = bernoulli(link = "logit"),
      y ~ 1 + (1 | s),
      prior = c(prior(normal(0, 1.5), class = Intercept),
                prior(normal(0, 1), class = sd)),
      iter = 20000, warmup = 1000, thin = 10, chains = 4, cores = 4)
stop_time_binomial <- proc.time()
```

See how we're using `proc.time()` to record when we began and finished evaluating our `brm()` code? The last time we covered that was way back in chapter 3. In chapter 3 we also learned how subtracting the former from the latter yields the total elapsed time.

``` r
stop_time_bernoulli - start_time_bernoulli
```

    ##    user  system elapsed 
    ## 102.431   3.118 280.219

``` r
stop_time_binomial - start_time_binomial
```

    ##    user  system elapsed 
    ## 101.000   3.414 255.444

If you wanted to be rigorous about this, you could do this multiple times in a mini simulation.

As to the issue of parallel processing, we’ve been doing this all along. Note our `chains = 4, cores = 4` code.

Extending the hierarchy: Subjects within categories
---------------------------------------------------

### Example: Baseball batting abilities by position.

Here are the batting average data, `ba`.

``` r
ba <- read_csv("data.R/BattingAverage.csv")

glimpse(ba)
```

    ## Observations: 948
    ## Variables: 6
    ## $ Player       <chr> "Fernando Abad", "Bobby Abreu", "Tony Abreu", "Du...
    ## $ PriPos       <chr> "Pitcher", "Left Field", "2nd Base", "2nd Base", ...
    ## $ Hits         <int> 1, 53, 18, 137, 21, 0, 0, 2, 150, 167, 0, 128, 66...
    ## $ AtBats       <int> 7, 219, 70, 607, 86, 1, 1, 20, 549, 576, 1, 525, ...
    ## $ PlayerNumber <int> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15...
    ## $ PriPosNumber <int> 1, 7, 4, 4, 3, 1, 1, 3, 3, 4, 1, 5, 4, 2, 7, 4, 6...

And here are the number of occasions by primary position, `PriPos`, with their median at bat, `AtBats`, values.

``` r
ba %>% 
  group_by(PriPos) %>% 
  summarise(n      = n(),
            median = median(AtBats)) %>% 
  arrange(desc(n))
```

    ## # A tibble: 9 x 3
    ##   PriPos           n median
    ##   <chr>        <int>  <dbl>
    ## 1 Pitcher        324     4 
    ## 2 Catcher        103   170 
    ## 3 Left Field     103   164 
    ## 4 1st Base        81   265 
    ## 5 3rd Base        75   267 
    ## 6 2nd Base        72   228.
    ## 7 Center Field    67   259 
    ## 8 Shortstop       63   205 
    ## 9 Right Field     60   340.

As these data are aggregated, we'll fit with an aggregated binomial model. This is still logistic regression. The Bernoulli distribution is a special case of the binomial distribution when the number of trials in each data point is 1 (see [this vignette](https://cran.r-project.org/web/packages/brms/vignettes/brms_families.html) for details). Since our data are aggregated, the information encoded in `Hits` is a combination of multiple trials, which requires us to jump up to the more general binomial likelihood. Note the `Hits  | trials(AtBats)` syntax. With that bit, we instructed brms that our criterion, `Hits`, is an aggregate of multiple trials and the number of trials is encoded in `AtBats`.

Also note the `(1 | PriPos) + (1 | PriPos:Player)` syntax. In this model, we have two grouping factors, `PriPos` and `Player`. Thus we have two `(|)` arguments. But since players are themselves nested within positions, we have encoded that nesting with the `(1 | PriPos:Player)` syntax. For more on this style of syntax, see [Kristoffer Magnusson’s handy post](http://rpsychologist.com/r-guide-longitudinal-lme-lmer#different-level-3-variance-covariance-matrix). Since brms syntax is based on that from the earlier nlme and lme4 packages, the basic syntax rules apply. Bürkner, of course, also covers these topics in the `brmsformula` subsection of his [brms reference manual](https://cran.r-project.org/web/packages/brms/brms.pdf).

``` r
fit2 <-
  brm(data = ba,
      family = binomial(link = "logit"),
      Hits  | trials(AtBats) ~ 1 + (1 | PriPos) + (1 | PriPos:Player),
      prior = c(prior(normal(0, 1.5), class = Intercept),
                prior(normal(0, 1), class = sd)),
      iter = 3500, warmup = 500, chains = 3, cores = 3,
      control = list(adapt_delta = .99))
```

The chains look good.

``` r
color_scheme_set("blue")

plot(fit2)
```

![](09_files/figure-markdown_github/unnamed-chunk-63-1.png)

We might examine the autocorrelations within the chains.

``` r
post <- posterior_samples(fit2, add_chain = T)

mcmc_acf(post, pars = c("b_Intercept", 
                        "sd_PriPos__Intercept", 
                        "sd_PriPos:Player__Intercept"), lags = 8)
```

![](09_files/figure-markdown_github/unnamed-chunk-64-1.png)

Here's a histogram of the *N*<sub>*e**f**f*</sub>/*N* ratios.

``` r
fit2 %>% 
  neff_ratio() %>% 
  mcmc_neff_hist(binwidth = .1) +
  yaxis_text()
```

![](09_files/figure-markdown_github/unnamed-chunk-65-1.png)

Happily, most have a very favorable ratio. Here's a numeric summary of the primary model parameters.

``` r
print(fit2)
```

    ##  Family: binomial 
    ##   Links: mu = logit 
    ## Formula: Hits | trials(AtBats) ~ 1 + (1 | PriPos) + (1 | PriPos:Player) 
    ##    Data: ba (Number of observations: 948) 
    ## Samples: 3 chains, each with iter = 3500; warmup = 500; thin = 1;
    ##          total post-warmup samples = 9000
    ## 
    ## Group-Level Effects: 
    ## ~PriPos (Number of levels: 9) 
    ##               Estimate Est.Error l-95% CI u-95% CI Eff.Sample Rhat
    ## sd(Intercept)     0.33      0.10     0.19     0.58       2480 1.00
    ## 
    ## ~PriPos:Player (Number of levels: 948) 
    ##               Estimate Est.Error l-95% CI u-95% CI Eff.Sample Rhat
    ## sd(Intercept)     0.14      0.01     0.12     0.15       3799 1.00
    ## 
    ## Population-Level Effects: 
    ##           Estimate Est.Error l-95% CI u-95% CI Eff.Sample Rhat
    ## Intercept    -1.17      0.11    -1.38    -0.94       1099 1.00
    ## 
    ## Samples were drawn using sampling(NUTS). For each parameter, Eff.Sample 
    ## is a crude measure of effective sample size, and Rhat is the potential 
    ## scale reduction factor on split chains (at convergence, Rhat = 1).

As far as I’m aware, brms offers three major ways to get the group-level parameters for a hierarchical model: using `posterior_samples()`, `coef()`, or `fitted()`. I’ll demonstrate each, in turn. We'll begin with `posterior_samples()`. In order to look at the autocorrelation plots, above, we already saved the `posterior_samples(fit2)` output as `post`. Here we'll look at its structure with `head()`. Before doing so we'll convert `post`, which is currently saved as a data frame, into a tibble in order to keep the output from getting unwieldy.

``` r
post <-
  post %>% 
  as_tibble()

head(post)
```

    ## # A tibble: 6 x 963
    ##   b_Intercept sd_PriPos__Interc… `sd_PriPos:Player__… `r_PriPos[1st.Base,…
    ##         <dbl>              <dbl>                <dbl>                <dbl>
    ## 1       -1.26              0.232                0.153               0.180 
    ## 2       -1.27              0.254                0.134               0.205 
    ## 3       -1.26              0.299                0.137               0.183 
    ## 4       -1.15              0.307                0.147               0.0912
    ## 5       -1.15              0.308                0.148               0.0814
    ## 6       -1.07              0.213                0.146              -0.0148
    ## # ... with 959 more variables: `r_PriPos[2nd.Base,Intercept]` <dbl>,
    ## #   `r_PriPos[3rd.Base,Intercept]` <dbl>,
    ## #   `r_PriPos[Catcher,Intercept]` <dbl>,
    ## #   `r_PriPos[Center.Field,Intercept]` <dbl>,
    ## #   `r_PriPos[Left.Field,Intercept]` <dbl>,
    ## #   `r_PriPos[Pitcher,Intercept]` <dbl>,
    ## #   `r_PriPos[Right.Field,Intercept]` <dbl>,
    ## #   `r_PriPos[Shortstop,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Adam.Dunn,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Adam.LaRoche,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Adam.Lind,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Adrian.Gonzalez,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Albert.Pujols,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Allen.Craig,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Anthony.Rizzo,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Aubrey.Huff,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Billy.Butler,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Brandon.Allen,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Brandon.Belt,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Brandon.Moss,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Brandon.Snyder,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Brent.Lillibridge,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Brett.Pill,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Brett.Wallace,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Bryan.LaHair,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Carlos.Lee,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Carlos.Pena,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Casey.Kotchman,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Casey.McGehee,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Chad.Tracy,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Chris.Carter,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Chris.Davis,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Chris.Parmelee,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Corey.Hart,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Dan.Johnson,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Daric.Barton,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_David.Cooper,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_David.Ortiz,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Edwin.Encarnacion,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Eric.Hinske,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Eric.Hosmer,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Freddie.Freeman,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Gaby.Sanchez,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Garrett.Jones,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Hector.Luna,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Ike.Davis,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_James.Loney,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Jason.Giambi,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Jeff.Clement,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Jim.Thome,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Joe.Mahoney,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Joey.Votto,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Juan.Rivera,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Justin.Morneau,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Justin.Smoak,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Kendrys.Morales,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Kila.Kaaihue,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Kyle.Blanks,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Lance.Berkman,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Luke.Scott,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Lyle.Overbay,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Mark.Reynolds,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Mark.Teixeira,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Mat.Gamel,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Matt.Adams,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Matt.Carpenter,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Matt.Downs,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Matt.Hague,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Matt.LaPorta,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Mauro.Gomez,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Michael.Young,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Miguel.Cairo,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Mike.Costanzo,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Mike.Jacobs,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Mike.Olt,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Mitch.Moreland,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Nick.Johnson,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Paul.Goldschmidt,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Paul.Konerko,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Prince.Fielder,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Ryan.Howard,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Steven.Hill,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Taylor.Green,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Todd.Helton,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Travis.Ishikawa,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Ty.Wigginton,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Yan.Gomes,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Yonder.Alonso,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[1st.Base_Zach.Lutz,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[2nd.Base_Aaron.Hill,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[2nd.Base_Adam.Rosales,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[2nd.Base_Adrian.Cardenas,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[2nd.Base_Alexi.Amarista,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[2nd.Base_Alexi.Casilla,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[2nd.Base_Blake.DeWitt,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[2nd.Base_Brandon.Phillips,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[2nd.Base_Brian.Roberts,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[2nd.Base_Brock.Holt,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[2nd.Base_Charlie.Culberson,Intercept]` <dbl>,
    ## #   `r_PriPos:Player[2nd.Base_Chase.dArnaud,Intercept]` <dbl>, …

In the text, Kruschke described the model as having 968 parameters. Our `post` tibble has one vector for each, with a couple others tacked onto the end. In the hierarchical logistic regression model, the group-specific parameters for the levels of `PriPos` are additive combinations of the global intercept vector, `b_Intercept` and each position-specific vector, `r_PriPos[i.Base,Intercept]`, where `i` is a fill-in for the position of interest. And recall that since the linear model is of the logit of the criterion, we’ll need to use `inv_logit_scaled()` to convert that to the probability space.

``` r
post_small <-
  post %>% 
  transmute(`1st Base` = (b_Intercept + `r_PriPos[1st.Base,Intercept]`), 
            Catcher    = (b_Intercept + `r_PriPos[Catcher,Intercept]`), 
            Pitcher    = (b_Intercept + `r_PriPos[Pitcher,Intercept]`)) %>% 
  mutate_all(inv_logit_scaled) %>% 
  # here we compute our difference distributions
  mutate(`Pitcher - Catcher`  = Pitcher - Catcher,
         `Catcher - 1st Base` = Catcher - `1st Base`)

head(post_small)
```

    ## # A tibble: 6 x 5
    ##   `1st Base` Catcher Pitcher `Pitcher - Catcher` `Catcher - 1st Base`
    ##        <dbl>   <dbl>   <dbl>               <dbl>                <dbl>
    ## 1      0.253   0.240   0.139             -0.101              -0.0127 
    ## 2      0.256   0.243   0.121             -0.122              -0.0127 
    ## 3      0.253   0.235   0.130             -0.104              -0.0186 
    ## 4      0.257   0.234   0.135             -0.0983             -0.0230 
    ## 5      0.256   0.233   0.132             -0.100              -0.0232 
    ## 6      0.253   0.250   0.127             -0.123              -0.00266

If you take a glance at Figures 9.14 through 9.16, we'll be making a lot of histograms of the same basic structure. We can make a histogram plotting function to streamline our code.

``` r
make_histogram <- function(data, mapping, title, xlim, ...){
  ggplot(data, mapping) +
  geom_histogram(fill = "grey67", color = "grey92", size = .2,
                bins = 30) +
  stat_pointintervalh(aes(y = 0), 
                      point_interval = mode_hdi, .width = .95) +
  scale_y_continuous(NULL, breaks = NULL) +
  labs(title = title,
       x     = expression(theta)) +
  coord_cartesian(xlim = xlim) +
  theme(legend.position = "none")
}
```

We'll do the same thing for the correlation plots.

``` r
make_point <- function(data, mapping, limits, ...){
  ggplot(data, mapping) +
  geom_abline(color = "white") +
  geom_point(color = "grey50", size = 1/10, alpha = 1/20) +
  coord_cartesian(xlim = limits,
                  ylim = limits)
}
```

To learn more about wrapping custom plots into custom functions, check out chapter 12 of Wickham's [*ggplot2, Elegant graphics for data analysis*](https://github.com/hadley/ggplot2-book).

Now we have our `make_histogram()` and `make_point()` functions, we'll use `grid.arrange()` to paste together the left half of Figure 9.14.

``` r
p1 <-
  make_histogram(data = post_small,
                 aes(x = Pitcher), 
                 title = "Pitcher", 
                 xlim = c(.1, .25))

p2 <-
  make_histogram(data = post_small,
                 aes(x = `Pitcher - Catcher`), 
                 title = "Pitcher - Catcher", 
                 xlim = c(-.15, 0))

p3 <-
  make_point(data = post_small,
             aes(x = Pitcher, y = Catcher),
             limits = c(.12, .25))

p4 <-
  make_histogram(data = post_small,
                 aes(x = Catcher), 
                 title = "Catcher", 
                 xlim = c(.1, .25))

grid.arrange(p1, p2, p3, p4, ncol = 2)
```

![](09_files/figure-markdown_github/unnamed-chunk-71-1.png)

We could follow the same procedure to make the right portion of Figure 9.14. But instead, let’s switch gears and explore the second way brms affords us for plotting group-level parameters. This time, we’ll use `coef()`.

Up in section 9.2.4, we learned that we can use `coef()` to "extract \[the\] model coefficients, which are the sum of population-level effects and corresponding group-level effects" (p. 39 of the [user's guide for brms](https://cran.r-project.org/web/packages/brms/brms.pdf) version 2.5.0). The grouping level we’re interested in is `PriPos`, so we’ll use that to index the information returned by `coef()`. Since `coef()` returns a matrix, we'll use `as_tibble()` to convert it to a tibble.

``` r
coef_primary_position <-
  coef(fit2, summary = F)$PriPos %>% 
  as_tibble()
  
str(coef_primary_position)
```

    ## Classes 'tbl_df', 'tbl' and 'data.frame':    9000 obs. of  9 variables:
    ##  $ 1st Base.Intercept    : num  -1.08 -1.07 -1.08 -1.06 -1.07 ...
    ##  $ 2nd Base.Intercept    : num  -1.07 -1.07 -1.09 -1.11 -1.09 ...
    ##  $ 3rd Base.Intercept    : num  -1.07 -1.07 -1.05 -1.02 -1.01 ...
    ##  $ Catcher.Intercept     : num  -1.15 -1.14 -1.18 -1.19 -1.19 ...
    ##  $ Center Field.Intercept: num  -1.05 -1.04 -1.03 -1.07 -1.06 ...
    ##  $ Left Field.Intercept  : num  -1.13 -1.1 -1.13 -1.11 -1.09 ...
    ##  $ Pitcher.Intercept     : num  -1.82 -1.98 -1.9 -1.85 -1.88 ...
    ##  $ Right Field.Intercept : num  -1.05 -1.06 -1.05 -1.09 -1.06 ...
    ##  $ Shortstop.Intercept   : num  -1.14 -1.13 -1.12 -1.05 -1.05 ...

Keep in mind that `coef()` returns the values in the logit scale when used for logistic regression models. So we’ll have to use `brms::inv_logit_scaled()` to convert the estimates to the probability metric. After we’re done converting the estimates, we’ll then make the difference distributions.

``` r
coef_small <-
  coef_primary_position %>% 
  select(`1st Base.Intercept`, Catcher.Intercept, Pitcher.Intercept) %>% 
  transmute(`1st Base` = `1st Base.Intercept`, 
            Catcher    = Catcher.Intercept, 
            Pitcher    = Pitcher.Intercept) %>% 
  mutate_all(inv_logit_scaled) %>% 
  # here we make the difference distributions
  mutate(`Pitcher - Catcher`  = Pitcher - Catcher,
         `Catcher - 1st Base` = Catcher - `1st Base`)

head(coef_small)
```

    ## # A tibble: 6 x 5
    ##   `1st Base` Catcher Pitcher `Pitcher - Catcher` `Catcher - 1st Base`
    ##        <dbl>   <dbl>   <dbl>               <dbl>                <dbl>
    ## 1      0.253   0.240   0.139             -0.101              -0.0127 
    ## 2      0.256   0.243   0.121             -0.122              -0.0127 
    ## 3      0.253   0.235   0.130             -0.104              -0.0186 
    ## 4      0.257   0.234   0.135             -0.0983             -0.0230 
    ## 5      0.256   0.233   0.132             -0.100              -0.0232 
    ## 6      0.253   0.250   0.127             -0.123              -0.00266

Now we're ready for the right half of Figure 9.14.

``` r
p1 <-
  make_histogram(data = coef_small,
                 aes(x = Catcher), 
                 title = "Catcher", 
                 xlim = c(.22, .27))

p2 <-
  make_histogram(data = coef_small,
                 aes(x = `Catcher - 1st Base`), 
                 title = "Catcher - 1st Base", 
                 xlim = c(-.04, .01))

p3 <-
  make_point(data = coef_small,
             aes(x = Catcher, y = `1st Base`),
             limits = c(.22, .27))

p4 <-
  make_histogram(data = coef_small,
                 aes(x = `1st Base`), 
                 title = "1st Base", 
                 xlim = c(.22, .27))

grid.arrange(p1, p2, p3, p4, ncol = 2)
```

![](09_files/figure-markdown_github/unnamed-chunk-74-1.png)

And if you wanted the posterior modes and HDIs, you'd use `mode_hdi()` after a little wrangling.

``` r
coef_small %>% 
  gather() %>% 
  group_by(key) %>% 
  mode_hdi(value) %>% 
  mutate_if(is.double, round, digits = 3)
```

    ## # A tibble: 5 x 7
    ##   key                 value .lower .upper .width .point .interval
    ##   <chr>               <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    
    ## 1 1st Base            0.254  0.245  0.262   0.95 mode   hdi      
    ## 2 Catcher             0.24   0.233  0.25    0.95 mode   hdi      
    ## 3 Catcher - 1st Base -0.013 -0.024  0       0.95 mode   hdi      
    ## 4 Pitcher             0.131  0.121  0.14    0.95 mode   hdi      
    ## 5 Pitcher - Catcher  -0.111 -0.124 -0.098   0.95 mode   hdi

While we're at it, we should capitalize on the opportunity to show how these results are the same as those derived from our `posterior_samples()` approach, above.

``` r
post_small %>% 
  gather() %>% 
  group_by(key) %>% 
  mode_hdi(value) %>% 
  mutate_if(is.double, round, digits = 3)
```

    ## # A tibble: 5 x 7
    ##   key                 value .lower .upper .width .point .interval
    ##   <chr>               <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    
    ## 1 1st Base            0.254  0.245  0.262   0.95 mode   hdi      
    ## 2 Catcher             0.24   0.233  0.25    0.95 mode   hdi      
    ## 3 Catcher - 1st Base -0.013 -0.024  0       0.95 mode   hdi      
    ## 4 Pitcher             0.131  0.121  0.14    0.95 mode   hdi      
    ## 5 Pitcher - Catcher  -0.111 -0.124 -0.098   0.95 mode   hdi

For Figures 9.15 and 9.16, Kruschke drilled down further into the posterior. To drill along with him, we'll take the opportunity to showcase `fitted()`, the third way brms affords us for plotting group-level parameters.

``` r
# this will make life easier. just go with it
name_list <- c("Kyle Blanks", "Bruce Chen", "ShinSoo Choo", "Ichiro Suzuki", 
               "Mike Leake", "Wandy Rodriguez", "Andrew McCutchen", "Brett Jackson")

# we'll define the data we'd like to feed into `fitted()`, here
nd <-
  ba %>% 
  filter(Player %in% c(name_list)) %>% 
  # these last two lines aren't typically necessary, 
  # but they allow us to arrange the rows in the same order we find the names in Figures 9.15 and 9.16
  mutate(Player = factor(Player, levels = c(name_list))) %>% 
  arrange(Player)

fitted_players <-
  fitted(fit2, 
       newdata = nd,
       scale = "linear",
       summary = F) %>% 
  as_tibble() %>% 
  # rename the values as returned by `as_tibble()`
  transmute(`Kyle Blanks`      = V1, 
            `Bruce Chen`       = V2, 
            `ShinSoo Choo`     = V3,
            `Ichiro Suzuki`    = V4,
            `Mike Leake`       = V5,
            `Wandy Rodriguez`  = V6,
            `Andrew McCutchen` = V7,
            `Brett Jackson`    = V8) %>% 
  # convert the values from the logit scale to the probability scale
  mutate_all(inv_logit_scaled) %>% 
  # in this last section, we make our difference distributions 
  mutate(`Kyle Blanks - Bruce Chen`         = `Kyle Blanks`      - `Bruce Chen`,
         `ShinSoo Choo - Ichiro Suzuki`     = `ShinSoo Choo`     - `Ichiro Suzuki`,
         `Mike Leake - Wandy Rodriguez`     = `Mike Leake`       - `Wandy Rodriguez`,
         `Andrew McCutchen - Brett Jackson` = `Andrew McCutchen` - `Brett Jackson`)
    
glimpse(fitted_players)
```

    ## Observations: 9,000
    ## Variables: 12
    ## $ `Kyle Blanks`                      <dbl> 0.3326507, 0.2370519, 0.253...
    ## $ `Bruce Chen`                       <dbl> 0.1537690, 0.1338514, 0.143...
    ## $ `ShinSoo Choo`                     <dbl> 0.2842733, 0.2735516, 0.301...
    ## $ `Ichiro Suzuki`                    <dbl> 0.2719869, 0.2833117, 0.279...
    ## $ `Mike Leake`                       <dbl> 0.1284509, 0.1253468, 0.115...
    ## $ `Wandy Rodriguez`                  <dbl> 0.1268515, 0.1214728, 0.115...
    ## $ `Andrew McCutchen`                 <dbl> 0.2905069, 0.3091637, 0.292...
    ## $ `Brett Jackson`                    <dbl> 0.2409799, 0.2471181, 0.233...
    ## $ `Kyle Blanks - Bruce Chen`         <dbl> 0.17888166, 0.10320047, 0.1...
    ## $ `ShinSoo Choo - Ichiro Suzuki`     <dbl> 0.012286433, -0.009760154, ...
    ## $ `Mike Leake - Wandy Rodriguez`     <dbl> 0.001599381, 0.003874029, 0...
    ## $ `Andrew McCutchen - Brett Jackson` <dbl> 0.04952696, 0.06204556, 0.0...

Note our use of the `scale = "linear"` argument in the `fitted()` function. By default, `fitted()` returns predictions on the scale of the criterion. But we don't want a list of successes and failures; we want player-level parameters. When you specify `scale = "linear"`, you request `fitted()` return the values in the parameter scale.

Figure 9.15, left:

``` r
p1 <-
  make_histogram(data = fitted_players,
                 aes(x = `Kyle Blanks`), 
                 title = "Kyle Blanks (1st Base)", 
                 xlim = c(.05, .35))

p2 <-
  make_histogram(data = fitted_players,
                 aes(x = `Kyle Blanks - Bruce Chen`), 
                 title = "Kyle Blanks (1st Base) -\nBruce Chen (Pitcher)", 
                 xlim = c(-.1, .25))

p3 <-
  make_point(data = fitted_players,
             aes(x = `Kyle Blanks`, y = `Bruce Chen`),
             limits = c(.09, .35))

p4 <-
  make_histogram(data = fitted_players,
                 aes(x = `Bruce Chen`), 
                 title = "Bruce Chen (Pitcher)", 
                 xlim = c(.05, .35))

grid.arrange(p1, p2, p3, p4, ncol = 2)
```

![](09_files/figure-markdown_github/unnamed-chunk-78-1.png)

Figure 9.15, right:

``` r
p1 <-
  make_histogram(data = fitted_players,
                 aes(x = `ShinSoo Choo`), 
                 title = "ShinSoo Choo (Right Field)", 
                 xlim = c(.22, .34))

p2 <-
  make_histogram(data = fitted_players,
                 aes(x = `ShinSoo Choo - Ichiro Suzuki`), 
                 title = "ShinSoo Choo (Right Field) -\nIchiro Suzuki (Right Field)", 
                 xlim = c(-.07, .07))

p3 <-
  make_point(data = fitted_players,
             aes(x = `ShinSoo Choo`, y = `Ichiro Suzuki`),
             limits = c(.23, .32))

p4 <-
  make_histogram(data = fitted_players,
                 aes(x = `Ichiro Suzuki`), 
                 title = "Ichiro Suzuki (Right Field)", 
                 xlim = c(.22, .34))

grid.arrange(p1, p2, p3, p4, ncol = 2)
```

![](09_files/figure-markdown_github/unnamed-chunk-79-1.png)

Figure 9.16, left:

``` r
p1 <-
  make_histogram(data = fitted_players,
                 aes(x = `Mike Leake`), 
                 title = "Mike Leake (Pitcher)", 
                 xlim = c(.05, .35))

p2 <-
  make_histogram(data = fitted_players,
                 aes(x = `Mike Leake - Wandy Rodriguez`), 
                 title = "Mike Leake (Pitcher) -\nWandy Rodriguez (Pitcher)", 
                 xlim = c(-.05, .25))

p3 <-
  make_point(data = fitted_players,
             aes(x = `Mike Leake`, y = `Wandy Rodriguez`),
             limits = c(.07, .25))

p4 <-
  make_histogram(data = fitted_players,
                 aes(x = `Wandy Rodriguez`), 
                 title = "Wandy Rodriguez (Pitcher)", 
                 xlim = c(.05, .35))

grid.arrange(p1, p2, p3, p4, ncol = 2)
```

![](09_files/figure-markdown_github/unnamed-chunk-80-1.png)

Figure 9.16, right:

``` r
p1 <-
  make_histogram(data = fitted_players,
                 aes(x = `Andrew McCutchen`), 
                 title = "Andrew McCutchen (Center Field)", 
                 xlim = c(.15, .35))

p2 <-
  make_histogram(data = fitted_players,
                 aes(x = `Andrew McCutchen - Brett Jackson`), 
                 title = "Andrew McCutchen (Center Field) -\nBrett Jackson (Center Field)", 
                 xlim = c(0, .20))

p3 <-
  make_point(data = fitted_players,
             aes(x = `Andrew McCutchen`, y = `Brett Jackson`),
             limits = c(.15, .35))

p4 <-
  make_histogram(data = fitted_players,
                 aes(x = `Brett Jackson`), 
                 title = "Brett Jackson (Center Field)", 
                 xlim = c(.15, .35))

grid.arrange(p1, p2, p3, p4, ncol = 2)
```

![](09_files/figure-markdown_github/unnamed-chunk-81-1.png)

And if you wanted the posterior modes and HDIs, you'd use `mode_hdi()` after a little wrangling.

``` r
fitted_players %>% 
  gather() %>% 
  group_by(key) %>% 
  mode_hdi(value) %>% 
  mutate_if(is.double, round, digits = 3)
```

    ## # A tibble: 12 x 7
    ##    key                         value .lower .upper .width .point .interval
    ##    <chr>                       <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    
    ##  1 Andrew McCutchen            0.306  0.275  0.338   0.95 mode   hdi      
    ##  2 Andrew McCutchen - Brett J… 0.074  0.021  0.123   0.95 mode   hdi      
    ##  3 Brett Jackson               0.236  0.194  0.276   0.95 mode   hdi      
    ##  4 Bruce Chen                  0.132  0.101  0.163   0.95 mode   hdi      
    ##  5 Ichiro Suzuki               0.276  0.248  0.305   0.95 mode   hdi      
    ##  6 Kyle Blanks                 0.252  0.201  0.304   0.95 mode   hdi      
    ##  7 Kyle Blanks - Bruce Chen    0.117  0.062  0.183   0.95 mode   hdi      
    ##  8 Mike Leake                  0.15   0.116  0.184   0.95 mode   hdi      
    ##  9 Mike Leake - Wandy Rodrigu… 0.025 -0.015  0.07    0.95 mode   hdi      
    ## 10 ShinSoo Choo                0.274  0.245  0.304   0.95 mode   hdi      
    ## 11 ShinSoo Choo - Ichiro Suzu… 0     -0.042  0.04    0.95 mode   hdi      
    ## 12 Wandy Rodriguez             0.123  0.096  0.154   0.95 mode   hdi

References
----------

Kruschke, J. K. (2015). *Doing Bayesian data analysis, Second Edition: A tutorial with R, JAGS, and Stan.* Burlington, MA: Academic Press/Elsevier.

Session info
------------

``` r
sessionInfo()
```

    ## R version 3.5.1 (2018-07-02)
    ## Platform: x86_64-apple-darwin15.6.0 (64-bit)
    ## Running under: macOS High Sierra 10.13.6
    ## 
    ## Matrix products: default
    ## BLAS: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRblas.0.dylib
    ## LAPACK: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRlapack.dylib
    ## 
    ## locale:
    ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
    ## 
    ## attached base packages:
    ## [1] stats     graphics  grDevices utils     datasets  methods   base     
    ## 
    ## other attached packages:
    ##  [1] gridExtra_2.3   tidybayes_1.0.1 bayesplot_1.6.0 brms_2.5.0     
    ##  [5] Rcpp_0.12.18    bindrcpp_0.2.2  ggridges_0.5.0  forcats_0.3.0  
    ##  [9] stringr_1.3.1   dplyr_0.7.6     purrr_0.2.5     readr_1.1.1    
    ## [13] tidyr_0.8.1     tibble_1.4.2    ggplot2_3.0.0   tidyverse_1.2.1
    ## 
    ## loaded via a namespace (and not attached):
    ##  [1] nlme_3.1-137              matrixStats_0.54.0       
    ##  [3] xts_0.10-2                lubridate_1.7.4          
    ##  [5] threejs_0.3.1             httr_1.3.1               
    ##  [7] LaplacesDemon_16.1.1      rstan_2.17.3             
    ##  [9] rprojroot_1.3-2           tools_3.5.1              
    ## [11] backports_1.1.2           utf8_1.1.4               
    ## [13] R6_2.2.2                  DT_0.4                   
    ## [15] lazyeval_0.2.1            colorspace_1.3-2         
    ## [17] withr_2.1.2               tidyselect_0.2.4         
    ## [19] mnormt_1.5-5              Brobdingnag_1.2-5        
    ## [21] compiler_3.5.1            cli_1.0.0                
    ## [23] rvest_0.3.2               HDInterval_0.2.0         
    ## [25] arrayhelpers_1.0-20160527 xml2_1.2.0               
    ## [27] shinyjs_1.0               labeling_0.3             
    ## [29] colourpicker_1.0          scales_0.5.0             
    ## [31] dygraphs_1.1.1.5          mvtnorm_1.0-8            
    ## [33] psych_1.8.4               StanHeaders_2.17.2       
    ## [35] digest_0.6.15             foreign_0.8-70           
    ## [37] rmarkdown_1.10            base64enc_0.1-3          
    ## [39] pkgconfig_2.0.1           htmltools_0.3.6          
    ## [41] htmlwidgets_1.2           rlang_0.2.1              
    ## [43] readxl_1.1.0              rstudioapi_0.7           
    ## [45] shiny_1.1.0               svUnit_0.7-12            
    ## [47] bindr_0.1.1               zoo_1.8-2                
    ## [49] jsonlite_1.5              crosstalk_1.0.0          
    ## [51] gtools_3.8.1              inline_0.3.15            
    ## [53] magrittr_1.5              loo_2.0.0                
    ## [55] Matrix_1.2-14             munsell_0.5.0            
    ## [57] abind_1.4-5               stringi_1.2.3            
    ## [59] yaml_2.1.19               MASS_7.3-50              
    ## [61] ggstance_0.3              plyr_1.8.4               
    ## [63] grid_3.5.1                parallel_3.5.1           
    ## [65] promises_1.0.1            crayon_1.3.4             
    ## [67] miniUI_0.1.1.1            lattice_0.20-35          
    ## [69] haven_1.1.2               hms_0.4.2                
    ## [71] knitr_1.20                pillar_1.2.3             
    ## [73] igraph_1.2.1              markdown_0.8             
    ## [75] shinystan_2.5.0           codetools_0.2-15         
    ## [77] stats4_3.5.1              reshape2_1.4.3           
    ## [79] rstantools_1.5.0          glue_1.2.0               
    ## [81] evaluate_0.10.1           modelr_0.1.2             
    ## [83] httpuv_1.4.4.2            cellranger_1.1.0         
    ## [85] gtable_0.2.0              assertthat_0.2.0         
    ## [87] mime_0.5                  xtable_1.8-2             
    ## [89] broom_0.4.5               coda_0.19-1              
    ## [91] later_0.7.3               rsconnect_0.8.8          
    ## [93] viridisLite_0.3.0         shinythemes_1.1.1        
    ## [95] bridgesampling_0.4-0
